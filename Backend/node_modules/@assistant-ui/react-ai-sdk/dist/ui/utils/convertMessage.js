// src/ui/utils/convertMessage.ts
import { isToolUIPart } from "ai";
import {
  unstable_createMessageConverter
} from "@assistant-ui/react";
var convertParts = (message) => {
  if (!message.parts || message.parts.length === 0) {
    return [];
  }
  return message.parts.filter((p) => p.type !== "step-start" && p.type !== "file").map((part) => {
    const type = part.type;
    if (type === "text") {
      return {
        type: "text",
        text: part.text
      };
    }
    if (type === "reasoning") {
      return {
        type: "reasoning",
        text: part.text
      };
    }
    if (isToolUIPart(part)) {
      const toolName = type.replace("tool-", "");
      const toolCallId = part.toolCallId;
      let args = {};
      let result = void 0;
      let isError = false;
      if (part.state === "input-streaming" || part.state === "input-available") {
        args = part.input || {};
      } else if (part.state === "output-available") {
        args = part.input || {};
        result = part.output;
      } else if (part.state === "output-error") {
        args = part.input || {};
        isError = true;
        result = { error: part.errorText };
      }
      return {
        type: "tool-call",
        toolName,
        toolCallId,
        argsText: JSON.stringify(args),
        args,
        result,
        isError
      };
    }
    if (type === "dynamic-tool") {
      const toolName = part.toolName;
      const toolCallId = part.toolCallId;
      let args = {};
      let result = void 0;
      let isError = false;
      if (part.state === "input-streaming" || part.state === "input-available") {
        args = part.input || {};
      } else if (part.state === "output-available") {
        args = part.input || {};
        result = part.output;
      } else if (part.state === "output-error") {
        args = part.input || {};
        isError = true;
        result = { error: part.errorText };
      }
      return {
        type: "tool-call",
        toolName,
        toolCallId,
        argsText: JSON.stringify(args),
        args,
        result,
        isError
      };
    }
    if (type === "source-url") {
      return {
        type: "source",
        sourceType: "url",
        id: part.sourceId,
        url: part.url,
        title: part.title || ""
      };
    }
    if (type === "source-document") {
      console.warn(
        `Source document part type ${type} is not yet supported in conversion`
      );
      return null;
    }
    if (type.startsWith("data-")) {
      console.warn(
        `Data part type ${type} is not yet supported in conversion`
      );
      return null;
    }
    console.warn(`Unsupported message part type: ${type}`);
    return null;
  }).filter(Boolean);
};
var AISDKMessageConverter = unstable_createMessageConverter(
  (message) => {
    const createdAt = /* @__PURE__ */ new Date();
    switch (message.role) {
      case "user":
        return {
          role: "user",
          id: message.id,
          createdAt,
          content: convertParts(message),
          attachments: message.parts?.filter((p) => p.type === "file").map((part, idx) => {
            return {
              id: idx.toString(),
              type: part.mediaType.startsWith("image/") ? "image" : "file",
              name: part.filename ?? "file",
              content: [
                part.mediaType.startsWith("image/") ? {
                  type: "image",
                  image: part.url,
                  filename: part.filename
                } : {
                  type: "file",
                  filename: part.filename,
                  data: part.url,
                  mimeType: part.mediaType
                }
              ],
              contentType: part.mediaType ?? "unknown/unknown",
              status: { type: "complete" }
            };
          })
        };
      case "system":
        return {
          role: "system",
          id: message.id,
          createdAt,
          content: convertParts(message)
        };
      case "assistant":
        return {
          role: "assistant",
          id: message.id,
          createdAt,
          content: convertParts(message),
          metadata: {
            unstable_annotations: message.annotations,
            unstable_data: Array.isArray(message.data) ? message.data : message.data ? [message.data] : void 0,
            custom: {}
          }
        };
      default:
        console.warn(`Unsupported message role: ${message.role}`);
        return [];
    }
  }
);
export {
  AISDKMessageConverter
};
//# sourceMappingURL=convertMessage.js.map