{"version":3,"sources":["../../src/hooks/tap-state.ts"],"sourcesContent":["import { getCurrentResourceFiber } from \"../core/execution-context\";\nimport { StateUpdater, Cell, ResourceFiber } from \"../core/types\";\n\nexport const rerender = (fiber: ResourceFiber<any, any>) => {\n  if (fiber.renderContext) {\n    throw new Error(\"Resource updated during render\");\n  }\n  if (fiber.isNeverMounted) {\n    throw new Error(\"Resource updated before mount\");\n  }\n  // Only schedule rerender if currently mounted\n  if (fiber.isMounted) {\n    fiber.scheduleRerender();\n  }\n};\n\nfunction getStateCell<T>(\n  initialValue: T | (() => T),\n): Cell & { type: \"state\" } {\n  const fiber = getCurrentResourceFiber();\n  const index = fiber.currentIndex++;\n\n  // Check if we're trying to use more hooks than in previous renders\n  if (!fiber.isFirstRender && index >= fiber.cells.length) {\n    throw new Error(\n      \"Rendered more hooks than during the previous render. \" +\n        \"Hooks must be called in the exact same order in every render.\",\n    );\n  }\n\n  if (!fiber.cells[index]) {\n    // Initialize the value immediately\n    const value =\n      typeof initialValue === \"function\"\n        ? (initialValue as () => T)()\n        : initialValue;\n\n    const cell: Cell & { type: \"state\" } = {\n      type: \"state\",\n      value,\n      set: (updater: StateUpdater<T>) => {\n        const currentValue = cell.value;\n        const nextValue =\n          typeof updater === \"function\"\n            ? (updater as (prev: T) => T)(currentValue)\n            : updater;\n\n        if (!Object.is(currentValue, nextValue)) {\n          cell.value = nextValue;\n          rerender(fiber);\n        }\n      },\n    };\n\n    fiber.cells[index] = cell;\n  }\n\n  const cell = fiber.cells[index];\n  if (cell.type !== \"state\") {\n    throw new Error(\"Hook order changed between renders\");\n  }\n\n  return cell as Cell & { type: \"state\" };\n}\n\nexport function tapState<S = undefined>(): [\n  S | undefined,\n  (updater: StateUpdater<S>) => void,\n];\nexport function tapState<S>(\n  initial: S | (() => S),\n): [S, (updater: StateUpdater<S>) => void];\nexport function tapState<S>(\n  initial?: S | (() => S),\n): [S | undefined, (updater: StateUpdater<S>) => void] {\n  const cell = getStateCell(initial as S | (() => S));\n\n  return [cell.value, cell.set];\n}\n"],"mappings":";AAAA,SAAS,+BAA+B;AAGjC,IAAM,WAAW,CAAC,UAAmC;AAC1D,MAAI,MAAM,eAAe;AACvB,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AACA,MAAI,MAAM,gBAAgB;AACxB,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAEA,MAAI,MAAM,WAAW;AACnB,UAAM,iBAAiB;AAAA,EACzB;AACF;AAEA,SAAS,aACP,cAC0B;AAC1B,QAAM,QAAQ,wBAAwB;AACtC,QAAM,QAAQ,MAAM;AAGpB,MAAI,CAAC,MAAM,iBAAiB,SAAS,MAAM,MAAM,QAAQ;AACvD,UAAM,IAAI;AAAA,MACR;AAAA,IAEF;AAAA,EACF;AAEA,MAAI,CAAC,MAAM,MAAM,KAAK,GAAG;AAEvB,UAAM,QACJ,OAAO,iBAAiB,aACnB,aAAyB,IAC1B;AAEN,UAAMA,QAAiC;AAAA,MACrC,MAAM;AAAA,MACN;AAAA,MACA,KAAK,CAAC,YAA6B;AACjC,cAAM,eAAeA,MAAK;AAC1B,cAAM,YACJ,OAAO,YAAY,aACd,QAA2B,YAAY,IACxC;AAEN,YAAI,CAAC,OAAO,GAAG,cAAc,SAAS,GAAG;AACvC,UAAAA,MAAK,QAAQ;AACb,mBAAS,KAAK;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AAEA,UAAM,MAAM,KAAK,IAAIA;AAAA,EACvB;AAEA,QAAM,OAAO,MAAM,MAAM,KAAK;AAC9B,MAAI,KAAK,SAAS,SAAS;AACzB,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACtD;AAEA,SAAO;AACT;AASO,SAAS,SACd,SACqD;AACrD,QAAM,OAAO,aAAa,OAAwB;AAElD,SAAO,CAAC,KAAK,OAAO,KAAK,GAAG;AAC9B;","names":["cell"]}