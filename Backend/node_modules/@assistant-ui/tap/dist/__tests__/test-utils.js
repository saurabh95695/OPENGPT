// src/__tests__/test-utils.ts
import {
  createResourceFiber,
  unmountResource as unmountResourceFiber,
  renderResource as renderResourceFiber,
  commitResource
} from "../core/ResourceFiber.js";
import { tapState } from "../hooks/tap-state.js";
function createTestResource(type) {
  const rerenderCallback = () => {
    if (activeResources.has(fiber)) {
      const lastProps = propsMap.get(fiber);
      const result = renderResourceFiber(fiber, lastProps);
      commitResource(fiber, result);
      lastRenderResultMap.set(fiber, result);
    }
  };
  const fiber = createResourceFiber(type, rerenderCallback);
  return fiber;
}
var activeResources = /* @__PURE__ */ new Set();
var propsMap = /* @__PURE__ */ new WeakMap();
var lastRenderResultMap = /* @__PURE__ */ new WeakMap();
function renderTest(fiber, props) {
  propsMap.set(fiber, props);
  activeResources.add(fiber);
  const result = renderResourceFiber(fiber, props);
  commitResource(fiber, result);
  lastRenderResultMap.set(fiber, result);
  return result.state;
}
function unmountResource(fiber) {
  if (activeResources.has(fiber)) {
    unmountResourceFiber(fiber);
    activeResources.delete(fiber);
  }
}
function cleanupAllResources() {
  activeResources.forEach((fiber) => unmountResourceFiber(fiber));
  activeResources.clear();
}
function getCommittedState(fiber) {
  const lastResult = lastRenderResultMap.get(fiber);
  if (!lastResult) {
    throw new Error(
      "No render result found for fiber. Make sure to call renderResource first."
    );
  }
  return lastResult.state;
}
var TestSubscriber = class {
  callCount = 0;
  lastState;
  fiber;
  constructor(fiber) {
    this.fiber = fiber;
    const lastProps = propsMap.get(fiber) ?? void 0;
    const initialResult = renderResourceFiber(fiber, lastProps);
    commitResource(fiber, initialResult);
    this.lastState = initialResult.state;
    lastRenderResultMap.set(fiber, initialResult);
    activeResources.add(fiber);
  }
  cleanup() {
    if (activeResources.has(this.fiber)) {
      unmountResourceFiber(this.fiber);
      activeResources.delete(this.fiber);
    }
  }
};
var TestResourceManager = class {
  constructor(fiber) {
    this.fiber = fiber;
  }
  isActive = false;
  renderAndMount(props) {
    if (this.isActive) {
      throw new Error("Resource already active");
    }
    this.isActive = true;
    activeResources.add(this.fiber);
    propsMap.set(this.fiber, props);
    const result = renderResourceFiber(this.fiber, props);
    commitResource(this.fiber, result);
    lastRenderResultMap.set(this.fiber, result);
    return result.state;
  }
  cleanup() {
    if (this.isActive && activeResources.has(this.fiber)) {
      unmountResourceFiber(this.fiber);
      activeResources.delete(this.fiber);
      this.isActive = false;
    }
  }
};
function waitForNextTick() {
  return new Promise((resolve) => setTimeout(resolve, 0));
}
async function waitFor(condition, timeout = 1e3, interval = 10) {
  const start = Date.now();
  while (!condition()) {
    if (Date.now() - start > timeout) {
      throw new Error("Timeout waiting for condition");
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
}
function createCounterResource(initialValue = 0) {
  return (props) => {
    const value = props.value ?? initialValue;
    return { count: value };
  };
}
function createStatefulCounterResource() {
  return (props) => {
    const [count, setCount] = tapState(props.initial);
    return {
      count,
      increment: () => setCount((c) => c + 1),
      decrement: () => setCount((c) => c - 1)
    };
  };
}
export {
  TestResourceManager,
  TestSubscriber,
  cleanupAllResources,
  createCounterResource,
  createStatefulCounterResource,
  createTestResource,
  getCommittedState,
  renderTest,
  unmountResource,
  waitFor,
  waitForNextTick
};
//# sourceMappingURL=test-utils.js.map