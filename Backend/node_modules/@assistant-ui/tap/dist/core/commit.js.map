{"version":3,"sources":["../../src/core/commit.ts"],"sourcesContent":["import { ResourceFiber, RenderResult } from \"./types\";\n\nexport function commitRender<R, P>(\n  renderResult: RenderResult,\n  fiber: ResourceFiber<R, P>,\n): void {\n  // Process all tasks collected during render\n  renderResult.commitTasks.forEach((task) => {\n    const cellIndex = task.cellIndex;\n    const effectCell = fiber.cells[cellIndex]!;\n    if (effectCell.type !== \"effect\") {\n      throw new Error(\"Cannot find effect cell\");\n    }\n\n    // Check if deps changed\n    let shouldRunEffect = true;\n\n    if (effectCell.deps !== undefined && task.deps !== undefined) {\n      shouldRunEffect =\n        effectCell.deps.length !== task.deps.length ||\n        effectCell.deps.some((dep, j) => !Object.is(dep, task.deps![j]));\n    }\n\n    // Run cleanup if effect will re-run\n    if (shouldRunEffect) {\n      if (effectCell.mounted) {\n        if (typeof effectCell.deps !== typeof task.deps) {\n          throw new Error(\n            \"tapEffect called with and without dependencies across re-renders\",\n          );\n        }\n\n        try {\n          if (effectCell.mounted && effectCell.cleanup) {\n            effectCell.cleanup();\n          }\n        } finally {\n          effectCell.mounted = false;\n        }\n      }\n\n      try {\n        const cleanup = task.effect();\n\n        if (cleanup !== undefined && typeof cleanup !== \"function\") {\n          throw new Error(\n            \"An effect function must either return a cleanup function or nothing. \" +\n              `Received: ${typeof cleanup}`,\n          );\n        }\n\n        effectCell.mounted = true;\n        effectCell.cleanup =\n          typeof cleanup === \"function\" ? cleanup : undefined;\n        effectCell.deps = task.deps;\n      } catch (error) {\n        throw error;\n      }\n    }\n  });\n}\n\nexport function cleanupAllEffects<R, P>(executionContext: ResourceFiber<R, P>) {\n  let firstError: unknown | null = null;\n  // Run cleanups in reverse order\n  for (let i = executionContext.cells.length - 1; i >= 0; i--) {\n    const cell = executionContext.cells[i];\n    if (cell?.type === \"effect\" && cell.mounted && cell.cleanup) {\n      try {\n        cell.cleanup();\n      } catch (e) {\n        if (firstError == null) firstError = e;\n      } finally {\n        cell.mounted = false;\n      }\n    }\n  }\n  if (firstError != null) throw firstError;\n}\n"],"mappings":";AAEO,SAAS,aACd,cACA,OACM;AAEN,eAAa,YAAY,QAAQ,CAAC,SAAS;AACzC,UAAM,YAAY,KAAK;AACvB,UAAM,aAAa,MAAM,MAAM,SAAS;AACxC,QAAI,WAAW,SAAS,UAAU;AAChC,YAAM,IAAI,MAAM,yBAAyB;AAAA,IAC3C;AAGA,QAAI,kBAAkB;AAEtB,QAAI,WAAW,SAAS,UAAa,KAAK,SAAS,QAAW;AAC5D,wBACE,WAAW,KAAK,WAAW,KAAK,KAAK,UACrC,WAAW,KAAK,KAAK,CAAC,KAAK,MAAM,CAAC,OAAO,GAAG,KAAK,KAAK,KAAM,CAAC,CAAC,CAAC;AAAA,IACnE;AAGA,QAAI,iBAAiB;AACnB,UAAI,WAAW,SAAS;AACtB,YAAI,OAAO,WAAW,SAAS,OAAO,KAAK,MAAM;AAC/C,gBAAM,IAAI;AAAA,YACR;AAAA,UACF;AAAA,QACF;AAEA,YAAI;AACF,cAAI,WAAW,WAAW,WAAW,SAAS;AAC5C,uBAAW,QAAQ;AAAA,UACrB;AAAA,QACF,UAAE;AACA,qBAAW,UAAU;AAAA,QACvB;AAAA,MACF;AAEA,UAAI;AACF,cAAM,UAAU,KAAK,OAAO;AAE5B,YAAI,YAAY,UAAa,OAAO,YAAY,YAAY;AAC1D,gBAAM,IAAI;AAAA,YACR,kFACe,OAAO,OAAO;AAAA,UAC/B;AAAA,QACF;AAEA,mBAAW,UAAU;AACrB,mBAAW,UACT,OAAO,YAAY,aAAa,UAAU;AAC5C,mBAAW,OAAO,KAAK;AAAA,MACzB,SAAS,OAAO;AACd,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF,CAAC;AACH;AAEO,SAAS,kBAAwB,kBAAuC;AAC7E,MAAI,aAA6B;AAEjC,WAAS,IAAI,iBAAiB,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;AAC3D,UAAM,OAAO,iBAAiB,MAAM,CAAC;AACrC,QAAI,MAAM,SAAS,YAAY,KAAK,WAAW,KAAK,SAAS;AAC3D,UAAI;AACF,aAAK,QAAQ;AAAA,MACf,SAAS,GAAG;AACV,YAAI,cAAc,KAAM,cAAa;AAAA,MACvC,UAAE;AACA,aAAK,UAAU;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACA,MAAI,cAAc,KAAM,OAAM;AAChC;","names":[]}