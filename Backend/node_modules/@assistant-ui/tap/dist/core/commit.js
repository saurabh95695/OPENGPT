// src/core/commit.ts
function commitRender(renderResult, fiber) {
  renderResult.commitTasks.forEach((task) => {
    const cellIndex = task.cellIndex;
    const effectCell = fiber.cells[cellIndex];
    if (effectCell.type !== "effect") {
      throw new Error("Cannot find effect cell");
    }
    let shouldRunEffect = true;
    if (effectCell.deps !== void 0 && task.deps !== void 0) {
      shouldRunEffect = effectCell.deps.length !== task.deps.length || effectCell.deps.some((dep, j) => !Object.is(dep, task.deps[j]));
    }
    if (shouldRunEffect) {
      if (effectCell.mounted) {
        if (typeof effectCell.deps !== typeof task.deps) {
          throw new Error(
            "tapEffect called with and without dependencies across re-renders"
          );
        }
        try {
          if (effectCell.mounted && effectCell.cleanup) {
            effectCell.cleanup();
          }
        } finally {
          effectCell.mounted = false;
        }
      }
      try {
        const cleanup = task.effect();
        if (cleanup !== void 0 && typeof cleanup !== "function") {
          throw new Error(
            `An effect function must either return a cleanup function or nothing. Received: ${typeof cleanup}`
          );
        }
        effectCell.mounted = true;
        effectCell.cleanup = typeof cleanup === "function" ? cleanup : void 0;
        effectCell.deps = task.deps;
      } catch (error) {
        throw error;
      }
    }
  });
}
function cleanupAllEffects(executionContext) {
  let firstError = null;
  for (let i = executionContext.cells.length - 1; i >= 0; i--) {
    const cell = executionContext.cells[i];
    if (cell?.type === "effect" && cell.mounted && cell.cleanup) {
      try {
        cell.cleanup();
      } catch (e) {
        if (firstError == null) firstError = e;
      } finally {
        cell.mounted = false;
      }
    }
  }
  if (firstError != null) throw firstError;
}
export {
  cleanupAllEffects,
  commitRender
};
//# sourceMappingURL=commit.js.map