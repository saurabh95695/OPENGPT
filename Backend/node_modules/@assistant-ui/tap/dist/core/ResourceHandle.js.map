{"version":3,"sources":["../../src/core/ResourceHandle.ts"],"sourcesContent":["import { ResourceElement, Unsubscribe } from \"./types\";\nimport {\n  createResourceFiber,\n  unmountResource,\n  renderResource,\n  commitResource,\n} from \"./ResourceFiber\";\nimport { UpdateScheduler } from \"./scheduler\";\nimport { tapRef } from \"../hooks/tap-ref\";\nimport { tapState } from \"../hooks/tap-state\";\nimport { tapMemo } from \"../hooks/tap-memo\";\nimport { tapInlineResource } from \"../hooks/tap-inline-resource\";\nimport { tapEffect } from \"../hooks/tap-effect\";\n\nexport interface ResourceHandle<R, P> {\n  getState(): R;\n  subscribe(callback: () => void): Unsubscribe;\n  updateInput(props: P): void;\n  flushSync(): void;\n  dispose(): void;\n}\n\nconst HandleWrapperResource = <R, P>({\n  element,\n  onUpdateInput,\n  onFlushSync,\n  onDispose,\n}: {\n  element: ResourceElement<R, P>;\n  onUpdateInput: () => void;\n  onFlushSync: () => void;\n  onDispose: () => void;\n}): ResourceHandle<R, P> => {\n  const [props, setProps] = tapState(element.props);\n  const value = tapInlineResource({ type: element.type, props });\n  const subscribers = tapRef(new Set<() => void>()).current;\n  const valueRef = tapRef(value);\n\n  tapEffect(() => {\n    if (value !== valueRef.current) {\n      valueRef.current = value;\n      subscribers.forEach((callback) => callback());\n    }\n  });\n\n  const handle = tapMemo(\n    () => ({\n      getState: () => valueRef.current,\n      subscribe: (callback: () => void) => {\n        subscribers.add(callback);\n        return () => subscribers.delete(callback);\n      },\n      updateInput: (props: P) => {\n        onUpdateInput();\n        setProps(() => props);\n      },\n      flushSync: onFlushSync,\n      dispose: onDispose,\n    }),\n    [],\n  );\n\n  return handle;\n};\n\nexport const createResource = <R, P>(\n  element: ResourceElement<R, P>,\n  delayMount = false,\n): ResourceHandle<R, P> => {\n  let isMounted = !delayMount;\n  const props = {\n    element,\n    onUpdateInput: () => {\n      if (isMounted) return;\n      isMounted = true;\n      commitResource(fiber, lastRender);\n    },\n    onFlushSync: () => {\n      scheduler.flushSync();\n    },\n    onDispose: () => unmountResource(fiber),\n  };\n\n  const scheduler = new UpdateScheduler(() => {\n    lastRender = renderResource(fiber, props);\n    if (isMounted) commitResource(fiber, lastRender);\n  });\n\n  const fiber = createResourceFiber(HandleWrapperResource<R, P>, () =>\n    scheduler.markDirty(),\n  );\n\n  let lastRender = renderResource(fiber, props);\n  if (isMounted) commitResource(fiber, lastRender);\n  return lastRender.state;\n};\n"],"mappings":";AACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP,SAAS,uBAAuB;AAChC,SAAS,cAAc;AACvB,SAAS,gBAAgB;AACzB,SAAS,eAAe;AACxB,SAAS,yBAAyB;AAClC,SAAS,iBAAiB;AAU1B,IAAM,wBAAwB,CAAO;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAK4B;AAC1B,QAAM,CAAC,OAAO,QAAQ,IAAI,SAAS,QAAQ,KAAK;AAChD,QAAM,QAAQ,kBAAkB,EAAE,MAAM,QAAQ,MAAM,MAAM,CAAC;AAC7D,QAAM,cAAc,OAAO,oBAAI,IAAgB,CAAC,EAAE;AAClD,QAAM,WAAW,OAAO,KAAK;AAE7B,YAAU,MAAM;AACd,QAAI,UAAU,SAAS,SAAS;AAC9B,eAAS,UAAU;AACnB,kBAAY,QAAQ,CAAC,aAAa,SAAS,CAAC;AAAA,IAC9C;AAAA,EACF,CAAC;AAED,QAAM,SAAS;AAAA,IACb,OAAO;AAAA,MACL,UAAU,MAAM,SAAS;AAAA,MACzB,WAAW,CAAC,aAAyB;AACnC,oBAAY,IAAI,QAAQ;AACxB,eAAO,MAAM,YAAY,OAAO,QAAQ;AAAA,MAC1C;AAAA,MACA,aAAa,CAACA,WAAa;AACzB,sBAAc;AACd,iBAAS,MAAMA,MAAK;AAAA,MACtB;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,IACX;AAAA,IACA,CAAC;AAAA,EACH;AAEA,SAAO;AACT;AAEO,IAAM,iBAAiB,CAC5B,SACA,aAAa,UACY;AACzB,MAAI,YAAY,CAAC;AACjB,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,eAAe,MAAM;AACnB,UAAI,UAAW;AACf,kBAAY;AACZ,qBAAe,OAAO,UAAU;AAAA,IAClC;AAAA,IACA,aAAa,MAAM;AACjB,gBAAU,UAAU;AAAA,IACtB;AAAA,IACA,WAAW,MAAM,gBAAgB,KAAK;AAAA,EACxC;AAEA,QAAM,YAAY,IAAI,gBAAgB,MAAM;AAC1C,iBAAa,eAAe,OAAO,KAAK;AACxC,QAAI,UAAW,gBAAe,OAAO,UAAU;AAAA,EACjD,CAAC;AAED,QAAM,QAAQ;AAAA,IAAoB;AAAA,IAA6B,MAC7D,UAAU,UAAU;AAAA,EACtB;AAEA,MAAI,aAAa,eAAe,OAAO,KAAK;AAC5C,MAAI,UAAW,gBAAe,OAAO,UAAU;AAC/C,SAAO,WAAW;AACpB;","names":["props"]}