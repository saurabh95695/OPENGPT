"use client";

// src/context/react/AssistantApiContext.tsx
import {
  createContext,
  useContext,
  useMemo
} from "react";
import {
  normalizeEventSelector
} from "../../types/EventTypes.js";
import { ThreadViewportProvider } from "../providers/ThreadViewportProvider.js";
import { jsx } from "react/jsx-runtime";
var createAssistantApiField = (config) => {
  const fn = config.get;
  fn.source = config.source;
  fn.query = config.query;
  return fn;
};
var NO_OP_FN = () => () => {
};
var AssistantApiContext = createContext({
  threads: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error("Threads is only available inside <AssistantProvider />");
    }
  }),
  toolUIs: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error("ToolUIs is only available inside <AssistantProvider />");
    }
  }),
  threadListItem: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error(
        "ThreadListItem is only available inside <AssistantProvider />"
      );
    }
  }),
  thread: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error("Thread is only available inside <AssistantProvider />");
    }
  }),
  composer: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error(
        "Composer is only available inside <AssistantProvider />"
      );
    }
  }),
  message: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error(
        "Message is only available inside <ThreadPrimitive.Messages />"
      );
    }
  }),
  part: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error(
        "Part is only available inside <MessagePrimitive.Parts />"
      );
    }
  }),
  attachment: createAssistantApiField({
    source: null,
    query: {},
    get: () => {
      throw new Error(
        "Attachment is only available inside <MessagePrimitive.Attachments /> or <ComposerPrimitive.Attachments />"
      );
    }
  }),
  subscribe: NO_OP_FN,
  flushSync: NO_OP_FN,
  on: (selector) => {
    const { scope } = normalizeEventSelector(selector);
    throw new Error(`Event scope is not available in this component: ${scope}`);
  },
  registerModelContextProvider: () => {
    throw new Error(
      "Registering model context providers is only available inside <AssistantProvider />"
    );
  },
  __internal_getRuntime: () => {
    return null;
  }
});
var useAssistantApi = () => {
  return useContext(AssistantApiContext);
};
var mergeFns = (fn1, fn2) => {
  if (fn1 === NO_OP_FN) return fn2;
  if (fn2 === NO_OP_FN) return fn1;
  return (...args) => {
    fn1(...args);
    fn2(...args);
  };
};
var mergeFnsWithUnsubscribe = (fn1, fn2) => {
  if (fn1 === NO_OP_FN) return fn2;
  if (fn2 === NO_OP_FN) return fn1;
  return (...args) => {
    const unsubscribe1 = fn1(...args);
    const unsubscribe2 = fn2(...args);
    return () => {
      unsubscribe1();
      unsubscribe2();
    };
  };
};
var extendApi = (api, api2) => {
  const api2Subscribe = api2.subscribe;
  const api2FlushSync = api2.flushSync;
  return {
    ...api,
    ...api2,
    subscribe: mergeFnsWithUnsubscribe(
      api.subscribe,
      api2Subscribe ?? NO_OP_FN
    ),
    flushSync: mergeFns(api.flushSync, api2FlushSync ?? NO_OP_FN)
  };
};
var AssistantProvider = ({ api: api2, children }) => {
  const api = useAssistantApi();
  const extendedApi = useMemo(() => extendApi(api, api2), [api, api2]);
  return /* @__PURE__ */ jsx(AssistantApiContext.Provider, { value: extendedApi, children: /* @__PURE__ */ jsx(ThreadViewportProvider, { children }) });
};
export {
  AssistantProvider,
  createAssistantApiField,
  useAssistantApi
};
//# sourceMappingURL=AssistantApiContext.js.map