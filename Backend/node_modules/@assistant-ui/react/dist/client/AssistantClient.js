// src/client/AssistantClient.ts
import {
  tapMemo,
  resource,
  tapInlineResource,
  tapResource
} from "@assistant-ui/tap";
import { asStore, tapApi } from "../utils/tap-store/index.js";
import { useResource } from "@assistant-ui/tap/react";
import { useMemo } from "react";
import {
  checkEventScope,
  normalizeEventSelector
} from "../types/EventTypes.js";
import { EventManager } from "../legacy-runtime/client/EventManagerRuntimeClient.js";
import {
  createAssistantApiField
} from "../context/react/AssistantApiContext.js";
import { ToolUIClient } from "./ToolUIClient.js";
import { withEventsProvider } from "./EventContext.js";
var AssistantStore = resource(
  ({
    threads: threadsEl,
    registerModelContextProvider,
    __internal_runtime
  }) => {
    const events = tapInlineResource(EventManager());
    const { threads, toolUIs } = withEventsProvider(events, () => {
      return {
        toolUIs: tapInlineResource(ToolUIClient()),
        threads: tapResource(threadsEl, [threadsEl])
      };
    });
    const state = tapMemo(
      () => ({
        threads: threads.state,
        toolUIs: toolUIs.state
      }),
      [threads.state, toolUIs.state]
    );
    return tapApi({
      getState: () => state,
      threads: threads.api,
      toolUIs: toolUIs.api,
      on: events.on,
      registerModelContextProvider,
      __internal_getRuntime: () => __internal_runtime ?? null
    });
  }
);
var getClientFromStore = (client) => {
  const getItem = () => {
    return client.getState().api.threads.item("main");
  };
  return {
    threads: createAssistantApiField({
      source: "root",
      query: {},
      get: () => client.getState().api.threads
    }),
    toolUIs: createAssistantApiField({
      source: "root",
      query: {},
      get: () => client.getState().api.toolUIs
    }),
    thread: createAssistantApiField({
      source: "threads",
      query: { type: "main" },
      get: () => client.getState().api.threads.thread("main")
    }),
    threadListItem: createAssistantApiField({
      source: "threads",
      query: { type: "main" },
      get: () => getItem()
    }),
    composer: createAssistantApiField({
      source: "thread",
      query: {},
      get: () => client.getState().api.threads.thread("main").composer
    }),
    registerModelContextProvider(provider) {
      return client.getState().api.registerModelContextProvider(provider);
    },
    __internal_getRuntime() {
      return client.getState().api.__internal_getRuntime();
    },
    on(selector, callback) {
      const { event, scope } = normalizeEventSelector(selector);
      if (scope === "*") return client.getState().api.on(event, callback);
      if (checkEventScope("thread", scope, event) || checkEventScope("thread-list-item", scope, event) || checkEventScope("composer", scope, event)) {
        return client.getState().api.on(event, (e) => {
          if (e.threadId !== getItem().getState().id) return;
          callback(e);
        });
      }
      throw new Error(
        `Event scope is not available in this component: ${scope}`
      );
    },
    subscribe: client.subscribe,
    flushSync: client.flushSync
  };
};
var useAssistantClient = (props) => {
  const client = useResource(asStore(AssistantStore(props)));
  return useMemo(() => getClientFromStore(client), [client]);
};
export {
  useAssistantClient
};
//# sourceMappingURL=AssistantClient.js.map