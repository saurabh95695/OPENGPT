{"version":3,"sources":["../../../src/legacy-runtime/client/EventManagerRuntimeClient.ts"],"sourcesContent":["import { resource, tapMemo } from \"@assistant-ui/tap\";\nimport { Unsubscribe } from \"../../types/Unsubscribe\";\nimport {\n  AssistantEventMap,\n  AssistantEvent,\n  AssistantEventCallback,\n} from \"../../types/EventTypes\";\n\nexport type EventManager = {\n  on<TEvent extends AssistantEvent>(\n    event: TEvent,\n    callback: AssistantEventCallback<TEvent>,\n  ): Unsubscribe;\n  emit<TEvent extends Exclude<AssistantEvent, \"*\">>(\n    event: TEvent,\n    payload: AssistantEventMap[TEvent],\n  ): void;\n};\n\ntype ListenerMap = Omit<\n  Map<AssistantEvent, Set<AssistantEventCallback<AssistantEvent>>>,\n  \"get\" | \"set\"\n> & {\n  get<TEvent extends AssistantEvent>(\n    event: TEvent,\n  ): Set<AssistantEventCallback<TEvent>> | undefined;\n  set<TEvent extends AssistantEvent>(\n    event: TEvent,\n    value: Set<AssistantEventCallback<TEvent>>,\n  ): void;\n};\n\nexport const EventManager = resource(() => {\n  const events = tapMemo(() => {\n    const listeners: ListenerMap = new Map();\n\n    return {\n      on: (event, callback) => {\n        if (!listeners.has(event)) {\n          listeners.set(event, new Set());\n        }\n\n        const eventListeners = listeners.get(event)!;\n        eventListeners.add(callback);\n\n        return () => {\n          eventListeners.delete(callback);\n          if (eventListeners.size === 0) {\n            listeners.delete(event);\n          }\n        };\n      },\n\n      emit: (event, payload) => {\n        const eventListeners = listeners.get(event);\n        const wildcardListeners = listeners.get(\"*\");\n\n        if (!eventListeners && !wildcardListeners) return;\n\n        // make sure state updates flush\n        queueMicrotask(() => {\n          // Emit to specific event listeners\n          if (eventListeners) {\n            for (const callback of eventListeners) {\n              callback(payload);\n            }\n          }\n\n          // Emit to wildcard listeners\n          if (wildcardListeners) {\n            for (const callback of wildcardListeners) {\n              callback({ event, payload });\n            }\n          }\n        });\n      },\n    } satisfies EventManager;\n  }, []);\n\n  return events;\n});\n"],"mappings":";AAAA,SAAS,UAAU,eAAe;AAgC3B,IAAM,eAAe,SAAS,MAAM;AACzC,QAAM,SAAS,QAAQ,MAAM;AAC3B,UAAM,YAAyB,oBAAI,IAAI;AAEvC,WAAO;AAAA,MACL,IAAI,CAAC,OAAO,aAAa;AACvB,YAAI,CAAC,UAAU,IAAI,KAAK,GAAG;AACzB,oBAAU,IAAI,OAAO,oBAAI,IAAI,CAAC;AAAA,QAChC;AAEA,cAAM,iBAAiB,UAAU,IAAI,KAAK;AAC1C,uBAAe,IAAI,QAAQ;AAE3B,eAAO,MAAM;AACX,yBAAe,OAAO,QAAQ;AAC9B,cAAI,eAAe,SAAS,GAAG;AAC7B,sBAAU,OAAO,KAAK;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAAA,MAEA,MAAM,CAAC,OAAO,YAAY;AACxB,cAAM,iBAAiB,UAAU,IAAI,KAAK;AAC1C,cAAM,oBAAoB,UAAU,IAAI,GAAG;AAE3C,YAAI,CAAC,kBAAkB,CAAC,kBAAmB;AAG3C,uBAAe,MAAM;AAEnB,cAAI,gBAAgB;AAClB,uBAAW,YAAY,gBAAgB;AACrC,uBAAS,OAAO;AAAA,YAClB;AAAA,UACF;AAGA,cAAI,mBAAmB;AACrB,uBAAW,YAAY,mBAAmB;AACxC,uBAAS,EAAE,OAAO,QAAQ,CAAC;AAAA,YAC7B;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,GAAG,CAAC,CAAC;AAEL,SAAO;AACT,CAAC;","names":[]}