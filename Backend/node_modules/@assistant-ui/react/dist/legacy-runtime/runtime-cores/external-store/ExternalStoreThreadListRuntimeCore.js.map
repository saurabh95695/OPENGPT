{"version":3,"sources":["../../../../src/legacy-runtime/runtime-cores/external-store/ExternalStoreThreadListRuntimeCore.tsx"],"sourcesContent":["import type { Unsubscribe } from \"../../../types\";\nimport { ExternalStoreThreadRuntimeCore } from \"./ExternalStoreThreadRuntimeCore\";\nimport {\n  ThreadListItemCoreState,\n  ThreadListRuntimeCore,\n} from \"../core/ThreadListRuntimeCore\";\nimport { ExternalStoreThreadListAdapter } from \"./ExternalStoreAdapter\";\n\nexport type ExternalStoreThreadFactory = () => ExternalStoreThreadRuntimeCore;\n\nconst EMPTY_ARRAY = Object.freeze([]);\nconst DEFAULT_THREAD_ID = \"DEFAULT_THREAD_ID\";\nconst DEFAULT_THREADS = Object.freeze([DEFAULT_THREAD_ID]);\nconst DEFAULT_THREAD = Object.freeze({\n  id: DEFAULT_THREAD_ID,\n  remoteId: undefined,\n  externalId: undefined,\n  status: \"regular\",\n});\nconst RESOLVED_PROMISE = Promise.resolve();\nconst DEFAULT_THREAD_DATA = Object.freeze({\n  [DEFAULT_THREAD_ID]: DEFAULT_THREAD,\n});\n\nexport class ExternalStoreThreadListRuntimeCore\n  implements ThreadListRuntimeCore\n{\n  private _mainThreadId: string = DEFAULT_THREAD_ID;\n  private _threads: readonly string[] = DEFAULT_THREADS;\n  private _archivedThreads: readonly string[] = EMPTY_ARRAY;\n  private _threadData: Readonly<Record<string, ThreadListItemCoreState>> =\n    DEFAULT_THREAD_DATA;\n\n  public get isLoading() {\n    return this.adapter.isLoading ?? false;\n  }\n\n  public get newThreadId() {\n    return undefined;\n  }\n\n  public get threadIds() {\n    return this._threads;\n  }\n\n  public get archivedThreadIds() {\n    return this._archivedThreads;\n  }\n\n  public get threadData() {\n    return this._threadData;\n  }\n\n  public getLoadThreadsPromise() {\n    return RESOLVED_PROMISE;\n  }\n\n  private _mainThread: ExternalStoreThreadRuntimeCore;\n\n  public get mainThreadId() {\n    return this._mainThreadId;\n  }\n\n  constructor(\n    private adapter: ExternalStoreThreadListAdapter = {},\n    private threadFactory: ExternalStoreThreadFactory,\n  ) {\n    this._mainThread = this.threadFactory();\n    this.__internal_setAdapter(adapter, true);\n  }\n\n  public getMainThreadRuntimeCore() {\n    return this._mainThread;\n  }\n\n  public getThreadRuntimeCore(): never {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public getItemById(threadId: string) {\n    for (const thread of this.adapter.threads ?? []) {\n      if (thread.id === threadId) return thread as any;\n    }\n    for (const thread of this.adapter.archivedThreads ?? []) {\n      if (thread.id === threadId) return thread as any;\n    }\n    if (threadId === DEFAULT_THREAD_ID) return DEFAULT_THREAD;\n    return undefined;\n  }\n\n  public __internal_setAdapter(\n    adapter: ExternalStoreThreadListAdapter,\n    initialLoad = false,\n  ) {\n    const previousAdapter = this.adapter;\n    this.adapter = adapter;\n\n    const newThreadId = adapter.threadId ?? DEFAULT_THREAD_ID;\n    const newThreads = adapter.threads ?? EMPTY_ARRAY;\n    const newArchivedThreads = adapter.archivedThreads ?? EMPTY_ARRAY;\n\n    const previousThreadId = previousAdapter.threadId ?? DEFAULT_THREAD_ID;\n    const previousThreads = previousAdapter.threads ?? EMPTY_ARRAY;\n    const previousArchivedThreads =\n      previousAdapter.archivedThreads ?? EMPTY_ARRAY;\n\n    if (\n      !initialLoad &&\n      previousThreadId === newThreadId &&\n      previousThreads === newThreads &&\n      previousArchivedThreads === newArchivedThreads\n    ) {\n      return;\n    }\n\n    this._threadData = {\n      ...DEFAULT_THREAD_DATA,\n      ...Object.fromEntries(\n        adapter.threads?.map((t) => [\n          t.id,\n          {\n            ...t,\n            remoteId: t.remoteId,\n            externalId: t.externalId,\n            status: \"regular\",\n          },\n        ]) ?? [],\n      ),\n      ...Object.fromEntries(\n        adapter.archivedThreads?.map((t) => [\n          t.id,\n          {\n            ...t,\n            remoteId: t.remoteId,\n            externalId: t.externalId,\n            status: \"archived\",\n          },\n        ]) ?? [],\n      ),\n    };\n\n    if (previousThreads !== newThreads) {\n      this._threads = this.adapter.threads?.map((t) => t.id) ?? EMPTY_ARRAY;\n    }\n\n    if (previousArchivedThreads !== newArchivedThreads) {\n      this._archivedThreads =\n        this.adapter.archivedThreads?.map((t) => t.id) ?? EMPTY_ARRAY;\n    }\n\n    if (previousThreadId !== newThreadId) {\n      this._mainThreadId = newThreadId;\n      this._mainThread = this.threadFactory();\n    }\n\n    this._notifySubscribers();\n  }\n\n  public async switchToThread(threadId: string): Promise<void> {\n    if (this._mainThreadId === threadId) return;\n    const onSwitchToThread = this.adapter.onSwitchToThread;\n    if (!onSwitchToThread)\n      throw new Error(\n        \"External store adapter does not support switching to thread\",\n      );\n    onSwitchToThread(threadId);\n  }\n\n  public async switchToNewThread(): Promise<void> {\n    const onSwitchToNewThread = this.adapter.onSwitchToNewThread;\n    if (!onSwitchToNewThread)\n      throw new Error(\n        \"External store adapter does not support switching to new thread\",\n      );\n\n    onSwitchToNewThread();\n  }\n\n  public async rename(threadId: string, newTitle: string): Promise<void> {\n    const onRename = this.adapter.onRename;\n    if (!onRename)\n      throw new Error(\"External store adapter does not support renaming\");\n\n    onRename(threadId, newTitle);\n  }\n\n  public async detach(): Promise<void> {\n    // no-op\n  }\n\n  public async archive(threadId: string): Promise<void> {\n    const onArchive = this.adapter.onArchive;\n    if (!onArchive)\n      throw new Error(\"External store adapter does not support archiving\");\n\n    onArchive(threadId);\n  }\n\n  public async unarchive(threadId: string): Promise<void> {\n    const onUnarchive = this.adapter.onUnarchive;\n    if (!onUnarchive)\n      throw new Error(\"External store adapter does not support unarchiving\");\n\n    onUnarchive(threadId);\n  }\n\n  public async delete(threadId: string): Promise<void> {\n    const onDelete = this.adapter.onDelete;\n    if (!onDelete)\n      throw new Error(\"External store adapter does not support deleting\");\n\n    onDelete(threadId);\n  }\n\n  public initialize(): never {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  public generateTitle(): never {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  private _subscriptions = new Set<() => void>();\n\n  public subscribe(callback: () => void): Unsubscribe {\n    this._subscriptions.add(callback);\n    return () => this._subscriptions.delete(callback);\n  }\n\n  private _notifySubscribers() {\n    for (const callback of this._subscriptions) callback();\n  }\n}\n"],"mappings":"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","names":[]}