"use client";

// src/legacy-runtime/runtime-cores/assistant-transport/useAssistantTransportRuntime.tsx
import {
  asAsyncIterableStream
} from "assistant-stream/utils";
import { useExternalStoreRuntime } from "../external-store/useExternalStoreRuntime.js";
import { useState, useRef, useMemo } from "react";
import {
  AssistantMessageAccumulator,
  DataStreamDecoder,
  unstable_createInitialMessage as createInitialMessage
} from "assistant-stream";
import { useCommandQueue } from "./commandQueue.js";
import { useRunManager } from "./runManager.js";
import { useConvertedState } from "./useConvertedState.js";
import { useToolInvocations } from "./useToolInvocations.js";
import { toAISDKTools, getEnabledTools, createRequestHeaders } from "./utils.js";
import { useRemoteThreadListRuntime } from "../remote-thread-list/useRemoteThreadListRuntime.js";
import { InMemoryThreadListAdapter } from "../remote-thread-list/adapter/in-memory.js";
var useAssistantTransportThreadRuntime = (options) => {
  const agentStateRef = useRef(options.initialState);
  const [, rerender] = useState(0);
  const resumeFlagRef = useRef(false);
  const commandQueue = useCommandQueue({
    onQueue: () => runManager.schedule()
  });
  const runManager = useRunManager({
    onRun: async (signal) => {
      const isResume = resumeFlagRef.current;
      resumeFlagRef.current = false;
      const commands = isResume ? [] : commandQueue.flush();
      if (commands.length === 0 && !isResume)
        throw new Error("No commands to send");
      const headers = await createRequestHeaders(options.headers);
      const context = runtime.thread.getModelContext();
      const response = await fetch(
        isResume ? options.resumeApi : options.api,
        {
          method: "POST",
          headers,
          body: JSON.stringify({
            commands,
            state: agentStateRef.current,
            system: context.system,
            tools: context.tools ? toAISDKTools(getEnabledTools(context.tools)) : void 0,
            ...context.callSettings,
            ...context.config,
            ...options.body
          }),
          signal
        }
      );
      options.onResponse?.(response);
      if (!response.ok) {
        throw new Error(`Status ${response.status}: ${await response.text()}`);
      }
      if (!response.body) {
        throw new Error("Response body is null");
      }
      let err;
      const stream = response.body.pipeThrough(new DataStreamDecoder()).pipeThrough(
        new AssistantMessageAccumulator({
          initialMessage: createInitialMessage({
            unstable_state: agentStateRef.current ?? null
          }),
          throttle: isResume,
          onError: (error) => {
            err = error;
          }
        })
      );
      let markedDelivered = false;
      for await (const chunk of asAsyncIterableStream(stream)) {
        if (chunk.metadata.unstable_state === agentStateRef.current) continue;
        if (!markedDelivered) {
          commandQueue.markDelivered();
          markedDelivered = true;
        }
        agentStateRef.current = chunk.metadata.unstable_state;
        rerender((prev) => prev + 1);
      }
      if (err) {
        throw new Error(err);
      }
    },
    onFinish: options.onFinish,
    onCancel: () => {
      const cmds = [
        ...commandQueue.state.inTransit,
        ...commandQueue.state.queued
      ];
      options.onCancel?.({
        commands: cmds,
        updateState: (updater) => {
          agentStateRef.current = updater(agentStateRef.current);
          rerender((prev) => prev + 1);
        }
      });
      commandQueue.reset();
    },
    onError: (error) => {
      const cmds = [...commandQueue.state.inTransit];
      options.onError?.(error, {
        commands: cmds,
        updateState: (updater) => {
          agentStateRef.current = updater(agentStateRef.current);
          rerender((prev) => prev + 1);
        }
      });
      commandQueue.markDelivered();
    }
  });
  const pendingCommands = useMemo(
    () => [...commandQueue.state.inTransit, ...commandQueue.state.queued],
    [commandQueue.state]
  );
  const converted = useConvertedState(
    options.converter,
    agentStateRef.current,
    pendingCommands,
    runManager.isRunning
  );
  const runtime = useExternalStoreRuntime({
    messages: converted.messages,
    state: converted.state,
    isRunning: converted.isRunning,
    adapters: options.adapters,
    onNew: async (message) => {
      if (message.role !== "user")
        throw new Error("Only user messages are supported");
      const parts = [];
      const content = [
        ...message.content,
        ...message.attachments?.flatMap((a) => a.content) ?? []
      ];
      for (const contentPart of content) {
        if (contentPart.type === "text") {
          parts.push({ type: "text", text: contentPart.text });
        } else if (contentPart.type === "image") {
          parts.push({ type: "image", image: contentPart.image });
        }
      }
      const command = {
        type: "add-message",
        message: {
          role: "user",
          parts
        }
      };
      commandQueue.enqueue(command);
    },
    onCancel: async () => {
      runManager.cancel();
      toolInvocations.abort();
    },
    onResume: async () => {
      if (!options.resumeApi)
        throw new Error("Must pass resumeApi to options to resume runs");
      resumeFlagRef.current = true;
      runManager.schedule();
    },
    onAddToolResult: async (toolOptions) => {
      const command = {
        type: "add-tool-result",
        toolCallId: toolOptions.toolCallId,
        result: toolOptions.result,
        toolName: toolOptions.toolName,
        isError: toolOptions.isError,
        ...toolOptions.artifact && { artifact: toolOptions.artifact }
      };
      commandQueue.enqueue(command);
    },
    onLoadExternalState: async (state) => {
      agentStateRef.current = state;
      toolInvocations.reset();
      rerender((prev) => prev + 1);
    }
  });
  const toolInvocations = useToolInvocations({
    state: converted,
    getTools: () => runtime.thread.getModelContext().tools,
    onResult: commandQueue.enqueue
  });
  return runtime;
};
var useAssistantTransportRuntime = (options) => {
  const runtime = useRemoteThreadListRuntime({
    runtimeHook: function RuntimeHook() {
      return useAssistantTransportThreadRuntime(options);
    },
    adapter: new InMemoryThreadListAdapter()
  });
  return runtime;
};
export {
  useAssistantTransportRuntime
};
//# sourceMappingURL=useAssistantTransportRuntime.js.map