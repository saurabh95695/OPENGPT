{"version":3,"sources":["../../../../src/legacy-runtime/runtime-cores/assistant-transport/useToolInvocations.ts"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\nimport {\n  createAssistantStreamController,\n  ToolCallStreamController,\n  ToolResponse,\n  unstable_toolResultStream,\n  type Tool,\n} from \"assistant-stream\";\nimport type {\n  AssistantTransportCommand,\n  AssistantTransportState,\n} from \"./types\";\nimport {\n  AssistantMetaTransformStream,\n  ReadonlyJSONValue,\n} from \"assistant-stream/utils\";\n\nconst isArgsTextComplete = (argsText: string) => {\n  try {\n    JSON.parse(argsText);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\ntype UseToolInvocationsParams = {\n  state: AssistantTransportState;\n  getTools: () => Record<string, Tool> | undefined;\n  onResult: (command: AssistantTransportCommand) => void;\n};\n\nexport function useToolInvocations({\n  state,\n  getTools,\n  onResult,\n}: UseToolInvocationsParams) {\n  const lastToolStates = useRef<\n    Record<\n      string,\n      {\n        argsText: string;\n        hasResult: boolean;\n        controller: ToolCallStreamController;\n      }\n    >\n  >({});\n\n  const acRef = useRef<AbortController>(new AbortController());\n  const [controller] = useState(() => {\n    const [stream, controller] = createAssistantStreamController();\n    const transform = unstable_toolResultStream(\n      getTools,\n      () => acRef.current?.signal ?? new AbortController().signal,\n    );\n    stream\n      .pipeThrough(transform)\n      .pipeThrough(new AssistantMetaTransformStream())\n      .pipeTo(\n        new WritableStream({\n          write(chunk) {\n            if (chunk.type === \"result\") {\n              // the tool call result was already set by the backend\n              if (lastToolStates.current[chunk.meta.toolCallId]?.hasResult)\n                return;\n\n              onResult({\n                type: \"add-tool-result\",\n                toolCallId: chunk.meta.toolCallId,\n                toolName: chunk.meta.toolName,\n                result: chunk.result,\n                isError: chunk.isError,\n                ...(chunk.artifact && { artifact: chunk.artifact }),\n              });\n            }\n          },\n        }),\n      );\n\n    return controller;\n  });\n\n  const ignoredToolIds = useRef<Set<string>>(new Set());\n  const isInititialState = useRef(true);\n\n  useEffect(() => {\n    if (isInititialState.current) {\n      state.messages.forEach((message) => {\n        message.content.forEach((content) => {\n          if (content.type === \"tool-call\") {\n            ignoredToolIds.current.add(content.toolCallId);\n          }\n        });\n      });\n      isInititialState.current = false;\n    } else {\n      state.messages.forEach((message) => {\n        message.content.forEach((content) => {\n          if (content.type === \"tool-call\") {\n            if (ignoredToolIds.current.has(content.toolCallId)) {\n              return;\n            }\n            let lastState = lastToolStates.current[content.toolCallId];\n            if (!lastState) {\n              const toolCallController = controller.addToolCallPart({\n                toolName: content.toolName,\n                toolCallId: content.toolCallId,\n              });\n              lastState = {\n                argsText: \"\",\n                hasResult: false,\n                controller: toolCallController,\n              };\n              lastToolStates.current[content.toolCallId] = lastState;\n            }\n\n            if (content.argsText !== lastState.argsText) {\n              if (!content.argsText.startsWith(lastState.argsText)) {\n                throw new Error(\n                  `Tool call argsText can only be appended, not updated: ${content.argsText} does not start with ${lastState.argsText}`,\n                );\n              }\n\n              const argsTextDelta = content.argsText.slice(\n                lastState.argsText.length,\n              );\n              lastState.controller.argsText.append(argsTextDelta);\n\n              if (isArgsTextComplete(content.argsText)) {\n                lastState.controller.argsText.close();\n              }\n\n              lastToolStates.current[content.toolCallId] = {\n                argsText: content.argsText,\n                hasResult: lastState.hasResult,\n                controller: lastState.controller,\n              };\n            }\n\n            if (content.result !== undefined && !lastState.hasResult) {\n              lastState.controller.setResponse(\n                new ToolResponse({\n                  result: content.result as ReadonlyJSONValue,\n                  artifact: content.artifact as ReadonlyJSONValue | undefined,\n                  isError: content.isError,\n                }),\n              );\n              lastState.controller.close();\n\n              lastToolStates.current[content.toolCallId] = {\n                hasResult: true,\n                argsText: lastState.argsText,\n                controller: lastState.controller,\n              };\n            }\n          }\n        });\n      });\n    }\n  }, [state]);\n\n  return {\n    reset: () => {\n      acRef.current.abort();\n      acRef.current = new AbortController();\n      isInititialState.current = true;\n    },\n    abort: () => {\n      acRef.current.abort();\n      acRef.current = new AbortController();\n    },\n  };\n}\n"],"mappings":"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","names":["controller"]}