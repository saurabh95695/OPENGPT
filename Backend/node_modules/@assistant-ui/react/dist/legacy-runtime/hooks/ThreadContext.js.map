{"version":3,"sources":["../../../src/legacy-runtime/hooks/ThreadContext.ts"],"sourcesContent":["\"use client\";\n\nimport { useState } from \"react\";\nimport { ThreadRuntime } from \"../runtime/ThreadRuntime\";\nimport { ModelContext } from \"../../model-context\";\nimport { createStateHookForRuntime } from \"../../context/react/utils/createStateHookForRuntime\";\nimport { ThreadComposerRuntime } from \"../runtime\";\nimport {\n  useAssistantApi,\n  useAssistantEvent,\n  useAssistantState,\n} from \"../../context/react\";\n\n/**\n * Hook to access the ThreadRuntime from the current context.\n *\n * The ThreadRuntime provides access to thread-level state and actions,\n * including message management, thread state, and composer functionality.\n *\n * @param options Configuration options\n * @param options.optional Whether the hook should return null if no context is found\n * @returns The ThreadRuntime instance, or null if optional is true and no context exists\n *\n * @example\n * ```tsx\n * function MyComponent() {\n *   const runtime = useThreadRuntime();\n *\n *   const handleSendMessage = (text: string) => {\n *     runtime.append({ role: \"user\", content: [{ type: \"text\", text }] });\n *   };\n *\n *   return <button onClick={() => handleSendMessage(\"Hello!\")}>Send</button>;\n * }\n * ```\n */\nexport function useThreadRuntime(options?: {\n  optional?: false | undefined;\n}): ThreadRuntime;\nexport function useThreadRuntime(options?: {\n  optional?: boolean | undefined;\n}): ThreadRuntime | null;\nexport function useThreadRuntime(options?: { optional?: boolean | undefined }) {\n  const api = useAssistantApi();\n  const runtime = useAssistantState(() =>\n    api.thread.source ? api.thread().__internal_getRuntime() : null,\n  );\n  if (!runtime && !options?.optional) {\n    throw new Error(\"ThreadRuntime is not available\");\n  }\n  return runtime;\n}\n\n/**\n * Hook to access the current thread state.\n *\n * This hook provides reactive access to the thread's state, including messages,\n * running status, capabilities, and other thread-level properties.\n *\n * @param selector Optional selector function to pick specific state properties\n * @returns The selected thread state or the entire thread state if no selector provided\n *\n * @example\n * ```tsx\n * function ThreadStatus() {\n *   const isRunning = useThread((state) => state.isRunning);\n *   const messageCount = useThread((state) => state.messages.length);\n *\n *   return <div>Running: {isRunning}, Messages: {messageCount}</div>;\n * }\n * ```\n */\nexport const useThread = createStateHookForRuntime(useThreadRuntime);\n\nconst useThreadComposerRuntime = (opt: {\n  optional: boolean | undefined;\n}): ThreadComposerRuntime | null => useThreadRuntime(opt)?.composer ?? null;\nexport const useThreadComposer = createStateHookForRuntime(\n  useThreadComposerRuntime,\n);\n\nexport function useThreadModelContext(options?: {\n  optional?: false | undefined;\n}): ModelContext;\nexport function useThreadModelContext(options?: {\n  optional?: boolean | undefined;\n}): ModelContext | null;\nexport function useThreadModelContext(options?: {\n  optional?: boolean | undefined;\n}): ModelContext | null {\n  const [, rerender] = useState({});\n\n  const runtime = useThreadRuntime(options);\n  useAssistantEvent(\"thread.model-context-update\", () => rerender({}));\n\n  if (!runtime) return null;\n  return runtime?.getModelContext();\n}\n"],"mappings":";;;AAEA,SAAS,gBAAgB;AAGzB,SAAS,iCAAiC;AAE1C;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AA+BA,SAAS,iBAAiB,SAA8C;AAC7E,QAAM,MAAM,gBAAgB;AAC5B,QAAM,UAAU;AAAA,IAAkB,MAChC,IAAI,OAAO,SAAS,IAAI,OAAO,EAAE,sBAAsB,IAAI;AAAA,EAC7D;AACA,MAAI,CAAC,WAAW,CAAC,SAAS,UAAU;AAClC,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AACA,SAAO;AACT;AAqBO,IAAM,YAAY,0BAA0B,gBAAgB;AAEnE,IAAM,2BAA2B,CAAC,QAEE,iBAAiB,GAAG,GAAG,YAAY;AAChE,IAAM,oBAAoB;AAAA,EAC/B;AACF;AAQO,SAAS,sBAAsB,SAEd;AACtB,QAAM,CAAC,EAAE,QAAQ,IAAI,SAAS,CAAC,CAAC;AAEhC,QAAM,UAAU,iBAAiB,OAAO;AACxC,oBAAkB,+BAA+B,MAAM,SAAS,CAAC,CAAC,CAAC;AAEnE,MAAI,CAAC,QAAS,QAAO;AACrB,SAAO,SAAS,gBAAgB;AAClC;","names":[]}