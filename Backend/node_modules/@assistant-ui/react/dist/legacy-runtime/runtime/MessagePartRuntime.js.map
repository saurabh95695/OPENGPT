{"version":3,"sources":["../../../src/legacy-runtime/runtime/MessagePartRuntime.ts"],"sourcesContent":["import {\n  ThreadAssistantMessagePart,\n  ThreadUserMessagePart,\n  MessagePartStatus,\n  ToolCallMessagePartStatus,\n} from \"../../types/AssistantTypes\";\nimport { ThreadRuntimeCoreBinding } from \"./ThreadRuntime\";\nimport type { MessageStateBinding } from \"./RuntimeBindings\";\nimport { SubscribableWithState } from \"./subscribable/Subscribable\";\nimport { Unsubscribe } from \"../../types\";\nimport { MessagePartRuntimePath } from \"./RuntimePathTypes\";\nimport { ToolResponse } from \"assistant-stream\";\n\nexport type MessagePartState = (\n  | ThreadUserMessagePart\n  | ThreadAssistantMessagePart\n) & {\n  readonly status: MessagePartStatus | ToolCallMessagePartStatus;\n};\n\ntype MessagePartSnapshotBinding = SubscribableWithState<\n  MessagePartState,\n  MessagePartRuntimePath\n>;\n\nexport type MessagePartRuntime = {\n  /**\n   * Add tool result to a tool call message part that has no tool result yet.\n   * This is useful when you are collecting a tool result via user input (\"human tool calls\").\n   */\n  addToolResult(result: any | ToolResponse<any>): void;\n\n  readonly path: MessagePartRuntimePath;\n  getState(): MessagePartState;\n  subscribe(callback: () => void): Unsubscribe;\n};\n\nexport class MessagePartRuntimeImpl implements MessagePartRuntime {\n  public get path() {\n    return this.contentBinding.path;\n  }\n\n  constructor(\n    private contentBinding: MessagePartSnapshotBinding,\n    private messageApi?: MessageStateBinding,\n    private threadApi?: ThreadRuntimeCoreBinding,\n  ) {\n    this.__internal_bindMethods();\n  }\n\n  protected __internal_bindMethods() {\n    this.addToolResult = this.addToolResult.bind(this);\n    this.getState = this.getState.bind(this);\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  public getState() {\n    return this.contentBinding.getState();\n  }\n\n  public addToolResult(result: any | ToolResponse<any>) {\n    const state = this.contentBinding.getState();\n    if (!state) throw new Error(\"Message part is not available\");\n\n    if (state.type !== \"tool-call\")\n      throw new Error(\"Tried to add tool result to non-tool message part\");\n\n    if (!this.messageApi)\n      throw new Error(\n        \"Message API is not available. This is likely a bug in assistant-ui.\",\n      );\n    if (!this.threadApi) throw new Error(\"Thread API is not available\");\n\n    const message = this.messageApi.getState();\n    if (!message) throw new Error(\"Message is not available\");\n\n    const toolName = state.toolName;\n    const toolCallId = state.toolCallId;\n\n    const response = ToolResponse.toResponse(result);\n    this.threadApi.getState().addToolResult({\n      messageId: message.id,\n      toolName,\n      toolCallId,\n      result: response.result,\n      artifact: response.artifact,\n      isError: response.isError,\n    });\n  }\n\n  public subscribe(callback: () => void) {\n    return this.contentBinding.subscribe(callback);\n  }\n}\n"],"mappings":";AAWA,SAAS,oBAAoB;AA0BtB,IAAM,yBAAN,MAA2D;AAAA,EAKhE,YACU,gBACA,YACA,WACR;AAHQ;AACA;AACA;AAER,SAAK,uBAAuB;AAAA,EAC9B;AAAA,EAVA,IAAW,OAAO;AAChB,WAAO,KAAK,eAAe;AAAA,EAC7B;AAAA,EAUU,yBAAyB;AACjC,SAAK,gBAAgB,KAAK,cAAc,KAAK,IAAI;AACjD,SAAK,WAAW,KAAK,SAAS,KAAK,IAAI;AACvC,SAAK,YAAY,KAAK,UAAU,KAAK,IAAI;AAAA,EAC3C;AAAA,EAEO,WAAW;AAChB,WAAO,KAAK,eAAe,SAAS;AAAA,EACtC;AAAA,EAEO,cAAc,QAAiC;AACpD,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,+BAA+B;AAE3D,QAAI,MAAM,SAAS;AACjB,YAAM,IAAI,MAAM,mDAAmD;AAErE,QAAI,CAAC,KAAK;AACR,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AACF,QAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM,6BAA6B;AAElE,UAAM,UAAU,KAAK,WAAW,SAAS;AACzC,QAAI,CAAC,QAAS,OAAM,IAAI,MAAM,0BAA0B;AAExD,UAAM,WAAW,MAAM;AACvB,UAAM,aAAa,MAAM;AAEzB,UAAM,WAAW,aAAa,WAAW,MAAM;AAC/C,SAAK,UAAU,SAAS,EAAE,cAAc;AAAA,MACtC,WAAW,QAAQ;AAAA,MACnB;AAAA,MACA;AAAA,MACA,QAAQ,SAAS;AAAA,MACjB,UAAU,SAAS;AAAA,MACnB,SAAS,SAAS;AAAA,IACpB,CAAC;AAAA,EACH;AAAA,EAEO,UAAU,UAAsB;AACrC,WAAO,KAAK,eAAe,UAAU,QAAQ;AAAA,EAC/C;AACF;","names":[]}